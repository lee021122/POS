const libShared = require('./lib-shared');

const initOptions = {
    /**
     * @type {Boolean}
     * By Default is False
     */
    pgFormatting: false,

    /**
     * @type {Boolean}
     */
    pgNative: false,

    promiseLib: Promise, 

    /**
     * Capitalizes any SQL generated by the library.
     * @type {Boolean}
     */
    capSQL: true,

    /**
     * @type {Boolean}
     */
    noWarnings: true,

    /**
     * 
     * @param {Object} e Event Properties
     * @param {Object} e.client Client Object // $[pg.Client] object that represents the connection.
     * @param {any} e.dc // Database Context that was used when creating the database object (see {@link Database}).
     * @param {number} e.useCount 
     * Number of times the connection has been previously used, starting with 0, for a freshly
     * allocated physical connection.
     */
    connect: (e) => {
        const cp = e.client.connectionParameters;
        console.log("CP: ", cp);
        
        console.log('Connected to database:', cp.database);
    },

    disconnect: (e) => {
        const cp = e.client.connectionParameters;
        console.log('Disconnected from the database');
    },

    query: e => {
        console.log('Query executed:', e.query);
    },

    receive: (data, result, e) => {
        console.log('Data received:', data);
    },

    error: (error, e) => {
        console.error('Database error:', error);
    },
    
};
const pgp = require('pg-promise')(initOptions)

const cn = {
    host: 'localhost',
    port: 5432,
    database: 'pos2',
    user: 'leehao',
    password: 'leehao',
    max: 30 // use up to 30 connections
}
const db = pgp(cn);

function pgSql() {};

Object.defineProperty(pgSql, 'SQL_INSERT', { get: function() { return 'INSERT INTO'; } });
Object.defineProperty(pgSql, 'SQL_VALUE', { get: function() { return 'VALUES'; } });

Object.defineProperty(pgSql, 'SQL_UPDATE', { get: function() { return 'UPDATE'; } });
Object.defineProperty(pgSql, 'SQL_SET', { get: function() { return 'SET'; } });

Object.defineProperty(pgSql, 'SQL_DELETE', { get: function() { return 'DELETE'; } });

Object.defineProperty(pgSql, 'SQL_FROM', { get: function () { return 'FROM'; } });
Object.defineProperty(pgSql, 'SQL_WHERE', { get: function () { return 'WHERE'; } });
Object.defineProperty(pgSql, 'SQL_AND', { get: function () { return 'AND'; } });
Object.defineProperty(pgSql, 'SQL_OR', { get: function () { return 'OR'; } });
Object.defineProperty(pgSql, 'SQL_ORDER_BY', { get: function () { return 'ORDRE BY'; } });

// Data Type (Postgres)
Object.defineProperty(pgSql, 'SQL_INT', { get: function () { return 'INT'; } });
Object.defineProperty(pgSql, 'SQL_VARCHAR', { get: function () { return 'VARCHAR'; } });
Object.defineProperty(pgSql, 'SQL_TEXT', { get: function () { return 'TEXT'; } });
Object.defineProperty(pgSql, 'SQL_DATE', { get: function () { return 'DATE'; } });
Object.defineProperty(pgSql, 'SQL_DATETIME', { get: function () { return 'DATETIME'; } });
Object.defineProperty(pgSql, 'SQL_TIMESTAMP', { get: function () { return 'TIMESTAMP'; } });
Object.defineProperty(pgSql, 'SQL_UUID', { get: function () { return 'UUID'; } });

// Data Type (Params)
Object.defineProperty(pgSql, 'PARAMS_STRING', { get: function () { return 'string'; } });
Object.defineProperty(pgSql, 'PARAMS_INTEGER', { get: function () { return 'int'; } });
Object.defineProperty(pgSql, 'PARAMS_MONEY', { get: function () { return 'money'; } });
Object.defineProperty(pgSql, 'PARAMS_GUID', { get: function () { return 'id'; } });
Object.defineProperty(pgSql, 'PARAMS_DATE', { get: function () { return 'dt'; } });
Object.defineProperty(pgSql, 'PARAMS_DATETIME', { get: function () { return 'dt2'; } });


Object.defineProperty(pgSql, 'SQL_ACTION', { get: function () { return 'fn_action_cmd'; } });

/**
 * 
 * @param {String} tb_name 
 * @param {String} sql 
 * @param {Array} cols
 * @param {Array} params 
 * @returns 
 */
pgSql.getTable = async function (tb_name, sql, cols, params) {
    try {
        // Ensure table name is safe to use to prevent SQL injection
        if (!pgSql.validTbOrFn(tb_name)) {
            throw new Error('Invalid table name');
        }
        
        // Validate column names to prevent SQL injection
        if (!Array.isArray(cols) || !cols.every(pgSql.validColumnName)) {
            throw new Error('Invalid column names');
        }

        // Construct the SQL query dynamically
        const columnList = cols.join(', ');
        const query = `SELECT ${columnList} FROM ${tb_name} ${sql || ''}`;
        
        // Execute the query and return the result
        return await db.any(query, params);
    } catch (error) {
        console.error('Error in getTable:', error);
        throw error;    
    }
};

/**
 * @param {String} name
 */
pgSql.validTbOrFn = function (name) {
    return /^[\w]+$/.test(name);
}

/**
 * 
 * @param {Array} col 
 * @returns 
 */
pgSql.validColumnName = function (col) {
    const regex = /^(fn_[a-zA-Z_][a-zA-Z0-9_]*)|([a-zA-Z_][a-zA-Z0-9_]*)$/;
    return regex.test(col);
};

pgSql.validProcName = async function (proc_name) {
    const regex = /^(pr_[a-zA-Z_][a-zA-Z0-9_]*)|([a-zA-Z_][a-zA-Z0-9_]*)$/;
    return regex.test(proc_name);
}


pgSql.executeFunction = async function (fn_name, params) {
    try {
        // Ensure function name is safe to use
        if (!pgSql.validTbOrFn(fn_name)) {
            throw new Error('Invalid function name');
        }
        
        // Construct the SQL function call dynamically
        const query = pgp.as.format('SELECT * FROM $1:name($2:csv)', [fn_name, params]);
        
        // Execute the function and return the result
        return await db.many(query);
    } catch (error) {
        console.error('Error in executeFunction:', error);
        throw error;
    }
};

pgSql.getAction = async function (axn_code) {
    try {
        // Call the function using db.func
        const result = await db.func(`${pgSql.SQL_ACTION}`, [axn_code]);

        // Return the result (which will be an array of rows)
        return {
            data: result,
            rowCount: result.length // This is how you get the number of rows
        };
    } catch (error) {
        console.error('Error in fetching action:', error);
        throw error; // Re-throw the error so it can be handled further up the chain
    }
};

pgSql.executeStoreProc = async function (sp_name, params) {
    try {
        if (!pgSql.validProcName(sp_name)) {
            throw new Error('Invalid procedure name');
        }

        const query = pgp.as.format('CALL $1:name($2:csv)', [sp_name, params]);

        return await db.many(query);
    } catch (err) {
        console.error('Error in executeStoreProc:', err);
        throw err;
    }
}

pgSql.toSql = function (data_type, v) {
    if (data_type === pgSql.PARAMS_STRING) {
        return `'${v}'`
    } else if (data_type === pgSql.PARAMS_INTEGER) {
        return libShared.toInt(v);
    } else if (data_type === pgSql.PARAMS_MONEY) {
        return libShared.toFloat(v);
    } 
    // else if (data_type === pgSql.PARAMS_DATE) {
    //     return 
    // } else if (data_type === pgSql.PARAMS_DATETIME) {
    //     return 
    // }
}

pgSql.appendLog = async function (log_type, log_data) {
    
};

module.exports = { pgSql, db };